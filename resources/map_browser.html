<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>Browse DK maps</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <style>
        input {
            all: unset;
        }

        input:focus {
            outline: unset;
            border-bottom: 1px solid rgb(244, 244, 244);
        }

        *,
        input {
            font-size: 105%;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
        }

        h1 {
            font-size: 110%;
        }

        body {
            background-color: rgb(30, 30, 30);
            color: #eee;
            margin: 2em;
        }

        table {
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.25);
        }

        table td {
            padding: 6px 9px;
            border: 1px solid rgb(44, 44, 44);
            transition: 0.5s all;
        }

        tr {
            cursor: pointer;
        }

        tr.active-cursor td {
            background-color: rgb(53, 1, 1);
            background-color: #b83810;
        }

        input {
            margin-bottom: 1em;
            background-color: rgb(30, 30, 30);
            border-bottom: 2px solid rgb(244, 244, 244);
            padding: 6px 3px;
        }
    </style>
</head>

<body>

    <h1>Dungeon Keeper map script browser</h1>
    <input placeholder="Search..." type="text" id="maps-search">
    <table id="maps-table"></table>

    <script>
        (function (api) {
            const MSG_TYPES = {
                build: "build"
            };
            const ELEMS = {
                mapsTable: document.getElementById("maps-table"),
                mapsSearch: document.getElementById("maps-search")
            };
            const ACTIVE_CURSOR_CLASS = "active-cursor";
            let maps = [];
            let filteredMaps = [];
            let filteredRows = [];
            let cursorIndex = -1;

            function handleChosenMap(map) {
                if (map) { api.postMessage(map); }
            }

            function handleSearchChange(searchFilter) {
                rebuild(searchFilter);
            }

            function handleKeyUpDown(direction) {
                let newVal = cursorIndex + direction;
                if (newVal < 0) { newVal = filteredMaps.length - 1; }
                if (newVal >= filteredMaps.length) { newVal = 0; }
                changeCursorIndex(newVal);
            }

            function changeCursorIndex(newVal) {
                if (filteredRows[cursorIndex]) {
                    filteredRows[cursorIndex].classList.remove(ACTIVE_CURSOR_CLASS);
                }
                if (filteredRows[newVal]) {
                    filteredRows[newVal].classList.add(ACTIVE_CURSOR_CLASS);
                }
                cursorIndex = newVal;
            }

            function handleEnter() {
                handleChosenMap(filteredMaps[cursorIndex]);
            }

            function rebuild(searchFilter) {
                function buildTableRow(mapName, mapTitle) {
                    const cell1 = document.createElement("TD");
                    const cell2 = document.createElement("TD");
                    const row = document.createElement("TR");
                    cell1.innerText = mapName.replace(/\.txt/i, "");
                    cell2.innerText = mapTitle;
                    row.appendChild(cell1);
                    row.appendChild(cell2);
                    return row;
                }
                ELEMS.mapsTable.innerHTML = "";
                cursorIndex = 0;
                filteredMaps = [];
                filteredRows = [];
                const fragment = new DocumentFragment;
                maps.forEach((map) => {
                    if (
                        !searchFilter
                        || map.name.toLowerCase().includes(searchFilter)
                        || map.title.toLowerCase().includes(searchFilter)
                    ) {
                        const newRow = buildTableRow(map.name, map.title);
                        const newRowIndex = filteredMaps.length;
                        fragment.appendChild(newRow);
                        newRow.addEventListener("click", function () {
                            handleChosenMap(map);
                        });

                        newRow.addEventListener("mouseenter", () => { changeCursorIndex(newRowIndex); });
                        filteredMaps.push(map);
                        filteredRows.push(newRow);
                    }
                });
                ELEMS.mapsTable.appendChild(fragment);
                changeCursorIndex(-1);
            }

            ELEMS.mapsSearch.addEventListener("keyup", function (e) {
                const upDownKeys = {
                    ArrowDown: 1,
                    ArrowUp: -1,
                };
                if (upDownKeys[e.key]) {
                    handleKeyUpDown(upDownKeys[e.key]);
                } else if (e.key === "Enter") {
                    handleEnter();
                } else {
                    handleSearchChange(e.target.value.toLowerCase());
                }
            })
            window.addEventListener("message", function (e) {
                const msg = e.data;
                if (msg.type === MSG_TYPES.build) {
                    maps = msg.maps;
                    rebuild("");
                }
            });
            // html autofocus is blocked, do this in js
            setTimeout(() => ELEMS.mapsSearch.focus());
        })(acquireVsCodeApi())
    </script>
</body>

</html>